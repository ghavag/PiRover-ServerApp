#!/usr/bin/python

# Dienstprogramm fuer den PiRover zur Ausfuehrung auf der Raspberry Pi.
#
# Autor: Alexander Graeb <mail@hpvag.de>
#
# Bugs:
#  * Alle Client-Verbindungen muessen erste geschlossen werden, damit das Programm vollstaendig terminiert.

### Konfigurationskonstanten. ###

LISTEN_ADDRESS = ""
LISTEN_PORT = 1987

# Zeichenfolge, welche zur Authentifizierung des Clients dient.
SECRET = "uMieY6ophu[a"

### Programm startet hier.
import SocketServer
import time
import md5
import signal
import thread
import sys
import socket

##### Fuer Techcammod
import RPi.GPIO as IO

cur_UpDown = 0 # Aktuelle Tastenstellung fuer linke (-1), rechte (1) oder keine (0) der beiden Tasten.
cur_LeftRight = 0 # Aktuelle Tastenstellung fuer nach oben (-1), nach unten (1) oder keine (0) der beiden Tasten.

# Konfiguration fuer die Pinbelegung (nach BCM-Belegung).
LEFT_FOR = 24
LEFT_REV = 25
RIGHT_FOR = 27
RIGHT_REV = 12

class ClientHandler(SocketServer.BaseRequestHandler):
	cc = 0

	def handle(self):
		print "Client connected from %s." % (self.client_address[0])

		client_authed = False

		while True:
			# Warte darauf, dass Client das Zauberwort sagt.
			data = self.request.recv(1024)

			if not data:
				break

			print "Received data from client: %s" % (data)

			# Begruesse Client und sende Salz fuer den Authentifizierungs-Hash mit.
			authsalt = str(time.time())

			if (data == 'Hello PiRover!\n'):
				self.request.send("PiRover 1.0 here! %s\n" % (authsalt))
			else:
				break

			if (ClientHandler.cc != 0):
				self.request.send("Client already connected!\n")
				break

			# Warte darauf, dass sich Client authentifiziert.
			data = self.request.recv(1024)

			if not data:
				break

			print "Received data from client: %s" % (data)

			if (data == (md5.new(SECRET + authsalt).hexdigest() + "\n")):
				print "Client auth ok!"
				self.request.send("OK\n");
				ClientHandler.cc += 1 # Erst nachdem sich client erfolgreich authentifiziert hat, wird er gezaehlt.
				client_authed = True
			else:
				print "Auth failed!"
				break

			data = self.request.recv(1024)
			self.request.settimeout(2) # recv()-Aufruf blockiert maximal 2 Sekunden.

			while (data):
				#print "Received data from client: %s" % (data)
				try:
					data = self.request.recv(1024)
				except socket.timeout:
					print "Timeout!"
					update_output(0, 0)

				# Kommandos vom Client auswerten.
				if (data == "UP pressed\n"):
					update_output(vertical = 1)
				elif (data == "DOWN pressed\n"):
					update_output(vertical = -1)
				elif ((data == "UP released\n") or (data == "DOWN released\n")):
					update_output(vertical = 0)
				elif (data == "LEFT pressed\n"):
					update_output(horizontal = -1)
				elif (data == "RIGHT pressed\n"):
					update_output(horizontal = 1)
				elif ((data == "LEFT released\n") or (data == "RIGHT released\n")):
					update_output(horizontal = 0)
				elif (data == "Keep alive\n"):
					pass
				else:
					update_output(0, 0)

		print "Connection to client %s closed." % self.client_address[0]

		if client_authed:
			ClientHandler.cc -= 1

# Routine, um SIGTERM abzufangen.
def signal_handler(signum, frame):
	print 'Signal handler called with signal', signum
	thread.start_new_thread(shutdown_thread, ())

# Das ist, weil die shutdown()-Methode von einem anderen Thread aus gerufen werden muss. Sonst Deadlock.
def shutdown_thread():
	global server
	print "Shuting down server thread called!"
	server.shutdown()
	server.server_close()

def update_output(vertical=None, horizontal=None):
	global cur_UpDown, cur_LeftRight

	# Tasten-Update uebernehmen.
	if (horizontal is not None):
		cur_LeftRight = horizontal

	if (vertical is not None):
		cur_UpDown = vertical

	if (cur_UpDown == -1 and cur_LeftRight == 0):
		r_speed = 1
		l_speed = 1
	elif (cur_UpDown == 1 and cur_LeftRight == 0):
		r_speed = -1
		l_speed = -1
	elif (cur_UpDown == 0 and cur_LeftRight == -1):
		r_speed = 1
		l_speed = -1
	elif (cur_UpDown == 0 and cur_LeftRight == 1):
		r_speed = -1
		l_speed = 1
	elif (cur_UpDown == -1 and cur_LeftRight == -1):
		r_speed = 0
		l_speed = 1
	elif (cur_UpDown == -1 and cur_LeftRight == 1):
		r_speed = 1
		l_speed = 0
	elif (cur_UpDown == 1 and cur_LeftRight == -1):
		r_speed = 0
		l_speed = -1
	elif (cur_UpDown == 1 and cur_LeftRight == 1):
		r_speed = -1
		l_speed = 0
	else:
		r_speed = 0
		l_speed = 0

	# Fuer die Ansteuerung der rechten Achse.
	if (r_speed == 1):
		IO.output(RIGHT_FOR, IO.HIGH)
		IO.output(RIGHT_REV, IO.LOW)
	elif (r_speed == -1):
		IO.output(RIGHT_FOR, IO.LOW)
		IO.output(RIGHT_REV, IO.HIGH)
	else:
		IO.output(RIGHT_FOR, IO.LOW)
		IO.output(RIGHT_REV, IO.LOW)

	# Fuer die Ansteuerung der linken Achse.
	if (l_speed == 1):
		IO.output(LEFT_FOR, IO.HIGH)
		IO.output(LEFT_REV, IO.LOW)
	elif (l_speed == -1):
		IO.output(LEFT_FOR, IO.LOW)
		IO.output(LEFT_REV, IO.HIGH)
	else:
		IO.output(LEFT_FOR, IO.LOW)
		IO.output(LEFT_REV, IO.LOW)

	print "=== Currend Speed ===\n\tl_speed=%d\n\tr_speed=%d" % (l_speed, r_speed)

### Einsprungspunkt fuer das Programm.
print "PiRover server started."

###### GPIO-Setup.
IO.setmode(IO.BCM) # Benutze GPIO-Nummerierung.
IO.setup(LEFT_FOR, IO.OUT)
IO.setup(LEFT_REV, IO.OUT)
IO.setup(RIGHT_FOR, IO.OUT)
IO.setup(RIGHT_REV, IO.OUT)

# Routine fuer das Signal SIGTERM mitteilen.
signal.signal(signal.SIGTERM, signal_handler)

# Und waehle diese Routine auch fuer SIGINT, also wenn das Programm ueber CTRL+C abgebrochen wurde.
signal.signal(signal.SIGINT, signal_handler)

server = SocketServer.ThreadingTCPServer((LISTEN_ADDRESS, LISTEN_PORT), ClientHandler)
server.serve_forever()

###### Fuer Techcammod
IO.cleanup()

print "Server stopped!"
